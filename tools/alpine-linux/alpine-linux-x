#!/usr/bin/env sh
# COPYRIGHT


set -e
set -f
set -u

program_name="alpine-linux-x"

_program_path_find()
{
	if [ "${0%/*}" = "$0" ]; then

		# We've been invoked by the interpreter as, say, bash program
		if [ -r "$0" ]; then
			pwd -P
		# Clutching at straws; probably run via a download, anonymous script, etc, weird execve, etc
		else
			printf '\n'
		fi

	else

		# We've been invoked with a relative or absolute path (also when invoked via PATH in a shell)

		_program_path_find_parentPath()
		{
			parentPath="${scriptPath%/*}"
			if [ -z "$parentPath" ]; then
				parentPath='/'
			fi
			cd "$parentPath" 1>/dev/null
		}

		# pdksh / mksh have problems with unsetting a variable that was never set...
		if [ "${CDPATH+set}" = 'set' ]; then
			unset CDPATH
		fi

		if command -v realpath 1>/dev/null 2>/dev/null; then
			(
				scriptPath="$(realpath "$0")"

				_program_path_find_parentPath
				pwd -P
			)
		elif command -v readlink 1>/dev/null 2>/dev/null; then
			(
				local recursionDepth=0
				_program_path_resolve_symlinks_recursively()
				{
					local unresolvedPath="$1"
					
					recursionDepth=$((recursionDepth + 1))
					
					if [ $recursionDepth -gt 10 ]; then
						printf '%s\n' 'Recursion to depths greater than 10 is not allowed when resolving links.'
						return 1
					fi
					
					local potentialLinkDestination="$(readlink -- "$unresolvedPath")"
					
					if [ -z "$potentialLinkDestination" ]; then
						scriptPath="$unresolvedPath"
						return 0
					fi
					local linkDestination="$potentialLinkDestination"
					local parentFolderPath="${unresolvedPath%/*}"
					
					if [ "$parentFolderPath" = "$unresolvedPath" ]; then
						_program_path_resolve_symlinks_recursively "$linkDestination"
					else
						case "$linkDestination" in
														
							/*)
								_program_path_resolve_symlinks_recursively "$linkDestination"
							;;
							
							*)
								_program_path_resolve_symlinks_recursively "$parentFolderPath"/"$linkDestination"
							;;
							
						esac
					fi
				}

				scriptPath="$0"
				_program_path_resolve_symlinks_recursively "$scriptPath"

				_program_path_find_parentPath
				pwd -P
			)
		else
			# This approach will fail in corner cases where the script itself is a symlink in a path not parallel with the concrete script
			(
				scriptPath="$0"

				_program_path_find_parentPath
				pwd -P
			)
		fi

	fi
}

fail()
{
	local message="$1"
	
	printf '%s:FAIL:%s\n' "$program_name" "$message" 1>&2
	exit 1
}

depends()
{
	local binary
	for binary in "$@"
	do
		if ! command -v "$binary" 1>/dev/null 2>/dev/null; then
			printf '%s:%s\n' "$program_name" "The binary `$binary` is not on the PATH"
			local EX_OSFILE=72
			exit $EX_OSFILE
		fi
	done
}

depends_binary()
{
	local binary
	for binary in "$@"
	do
		if [ ! -x "$binary" ]; then
			printf '%s:%s\n' "$program_name" "The binary `$binary` is not present"
			local EX_OSFILE=72
			exit $EX_OSFILE
		fi
	done
}

depends rm mkdir
alpine_linux_x_prepare()
{
	rm -rf "$alpine_linux_temporaryFolderPath"
	mkdir -m 0700 -p "$alpine_linux_temporaryFolderPath"

	_alpine_linux_x_prepare_rebuild()
	{
		local folderPath="$1"
		local usesPackages="$2"
		local usesBusyboxStaticBinaries="$3"

		if ! alpine_linux_cachedVersion "$folderPath"; then
			rm -rf "$folderPath"
			mkdir -m 0700 -p "$folderPath"
		fi

		if $usesPackages; then
			if ! alpine_linux_cachedPackages "$folderPath"; then
				rm -rf "$folderPath"
				mkdir -m 0700 -p "$folderPath"
			fi
		fi

		if $usesBusyboxStaticBinaries; then
			if ! alpine_linux_cachedBusyboxStaticBinaries "$folderPath"; then
				rm -rf "$folderPath"
				mkdir -m 0700 -p "$folderPath"
			fi
		fi
	}

	_alpine_linux_x_prepare_rebuild "$alpine_linux_extractFolderPath" true true
	_alpine_linux_x_prepare_rebuild "$alpine_linux_packagesFolderPath" true false
	_alpine_linux_x_prepare_rebuild "$alpine_linux_indexFolderPath" false false
	_alpine_linux_x_prepare_rebuild "$alpine_linux_mirrorFolderPath" false false
}

depends mv
alpine_linux_x_downloadNetbootFile()
{
	local fileName="$1"

	# Can also be 'virt'
 	local variant='vanilla'
	environment_download "$alpine_linux_temporaryFolderPath" "$alpine_linux_releasesMirror"/"$netbootFolderName"/"$fileName"-"$variant"
	mv "$alpine_linux_temporaryFolderPath"/"$fileName"-"$variant" "$alpine_linux_mirrorFolderPath"/"$fileName"
}

alpine_linux_x_downloadNetboot()
{
	local fileName
	for fileName in vmlinuz initramfs
	do
		alpine_linux_x_downloadNetbootFile "$fileName"
	done
}

alpine_linux_x_downloadApkIndex()
{
	local repositoryVariant="$1"

	local repositoryMirror
	alpine_linux_repositoryMirror "$repositoryVariant"

	environment_download "$alpine_linux_mirrorFolderPath" "${repositoryMirror}/${alpine_linux_architecture}/APKINDEX.tar.gz"
}

depends tar
alpine_linux_x_extractApkIndex()
{
	tar -x -f "$alpine_linux_mirrorFolderPath"/APKINDEX.tar.gz -C "$alpine_linux_temporaryFolderPath" APKINDEX
}

depends sort rm
alpine_linux_x_convertApkIndex()
{
	# Package name.
	local valueFor_P=''

	# Version.
	local valueFor_V=''

	# Licence.
	local valueFor_L=''

	# Dependencies.
	local valueFor_D=''

	# Package provides.
	local valueFor_p=''

	# Automatic Install Condition.
	local valueFor_i=''

	# Note that some shells are limited to file descriptors 0 to 9 inclusive.

	exec 3>"$alpine_linux_temporaryFolderPath"/APKINDEX.depends-so.raw
	exec 4>"$alpine_linux_temporaryFolderPath"/APKINDEX.depends-pc.raw
	printf '' >"$alpine_linux_temporaryFolderPath"/APKINDEX.depends-binary.raw
	exec 5>"$alpine_linux_temporaryFolderPath"/APKINDEX.depends-conflicts-package-or-virtual-package.raw
	exec 6>"$alpine_linux_temporaryFolderPath"/APKINDEX.depends-package-or-virtual-package.raw

	exec 7>"$alpine_linux_temporaryFolderPath"/APKINDEX.provides-so.raw
	exec 8>"$alpine_linux_temporaryFolderPath"/APKINDEX.provides-pc.raw
	exec 9>"$alpine_linux_temporaryFolderPath"/APKINDEX.provides-command.raw
	printf '' >"$alpine_linux_temporaryFolderPath"/APKINDEX.provides-binary.raw
	printf '' >"$alpine_linux_temporaryFolderPath"/APKINDEX.provides-virtual-package.raw

	local key
	local value
	while IFS=':' read -r key value 
	do
		# See https://wiki.alpinelinux.org/wiki/Apk_spec for definitions of the keys.
		case "$key" in

			'P')
				valueFor_P="$value"
			;;

			'V')
				valueFor_V="$value"
			;;

			'L')
				valueFor_L="$value"
			;;

			'D')
				valueFor_D="$value"

				sed 's/ /\n/g' >"$alpine_linux_temporaryFolderPath"/valueFor_D <<-EOF
					$valueFor_D
				EOF

				local depends
				while IFS='' read -r depends
				do
					case "$depends" in

						# eg o:libc.musl-x86_64.so.1 .
						'so:'*)
							local withoutPrefix="${depends#so:*}"
							local so="${withoutPrefix%%=*}"
							printf '%s\t%s\t%s\n' "$valueFor_P" "$so" >&3
						;;

						# eg p:so:libnftables.so.0 .
						'pc:'*)
							local withoutPrefix="${depends#pc:*}"
							local pc="${withoutPrefix%%=*}"
							printf '%s\t%s\t%s\n' "$valueFor_P" "$pc" >&4
						;;

						# eg /bin/sh .
						'/'*)
							printf '%s\t%s\n' "$valueFor_P" "$depends" >>"$alpine_linux_temporaryFolderPath"/APKINDEX.depends-binary.raw
						;;

						'')
							:
						;;

						# eg !hylafax .
						'!'*)
							local packageOrVirtualPackageName="${depends#!*}"
							printf '%s\t%s\n' "$valueFor_P" "$packageOrVirtualPackageName" >&5
						;;

						# Package or virtual package.
						*)
							local packageOrVirtualPackageName
							local operator
							local version
							case "$depends" in

								# TODO: BUG: >, >= may be parsed incorrectly.

								# eg openrc>=0.24.1-r6 .
								*'>='*)
									packageOrVirtualPackageName="${depends%%>=*}"
									operator='>='
									version="${depends##*>=}"
								;;

								# (no examples known).
								*'<='*)
									packageOrVirtualPackageName="${depends%%<=*}"
									operator='<='
									version="${depends##*<=}"
								;;

								# eg freeradius>3 .
								*'>'*)
									packageOrVirtualPackageName="${depends%%>*}"
									operator='>'
									version="${depends##*>}"
								;;

								# eg py2-alabaster<0.8 .
								*'<'*)
									packageOrVirtualPackageName="${depends%%<*}"
									operator='<'
									version="${depends##*<}"
								;;

								# eg git=2.20.1-r0 .
								*'='*)
									packageOrVirtualPackageName="${depends%%=*}"
									operator='='
									version="${depends##*=}"
								;;

								# eg python3 .
								*)
									packageOrVirtualPackageName="$depends"
									operator=''
									version=''
								;;

							esac

							printf '%s\t%s\t%s\t%s\n' "$valueFor_P" "$packageOrVirtualPackageName" "$operator" "$version" >&6
						;;

					esac
				done <"$alpine_linux_temporaryFolderPath"/valueFor_D
			;;

			'p')
				valueFor_p="$value"

				sed 's/ /\n/g' >"$alpine_linux_temporaryFolderPath"/valueFor_p <<-EOF
					$valueFor_p
				EOF

				local provides
				while IFS='' read -r provides
				do
					case "$provides" in

						# eg o:libc.musl-x86_64.so.1=1  where the value after '=' is the real version.
						'so:'*)
							local withoutPrefix="${provides#so:*}"
							local so="${withoutPrefix%%=*}"
							local realVersion="${withoutPrefix#*=}"
							printf '%s\t%s\t%s\n' "$so" "$valueFor_P" "$realVersion" >&7
						;;

						# eg p:so:libnftables.so.0=0.0.0  where the value after '=' is the real version.
						'pc:'*)
							local withoutPrefix="${provides#pc:*}"
							local pc="${withoutPrefix%%=*}"
							local realVersion="${withoutPrefix#*=}"
							printf '%s\t%s\t%s\n' "$pc" "$valueFor_P" "$realVersion" >&8
						;;

						# eg cmd:nft .
						'cmd:'*)
							local cmd="${provides#cmd:*}"
							printf '%s\t%s\n' "$cmd" "$valueFor_P" >&9
						;;

						# eg /bin/sh .
						'/'*)
							printf '%s\t%s\n' "$provides" "$valueFor_P" >>"$alpine_linux_temporaryFolderPath"/APKINDEX.provides-binary.raw
						;;

						'')
							:
						;;

						# Virtual packages, eg p:nginx-rtmp  rsyslog-fmhttp=8.40.0-r4	
						*)
							# TODO: BUG: Versioned virtual packages are not supported.
							printf '%s\t%s\n' "$provides" "$valueFor_P" >>"$alpine_linux_temporaryFolderPath"/APKINDEX.provides-virtual-package.raw
						;;

					esac
				done <"$alpine_linux_temporaryFolderPath"/valueFor_p
			;;

			'i')
				valueFor_i="$value"
			;;

			'')
				if [ -n "$valueFor_P" ]; then

					printf '%s\t' "$valueFor_P"
					printf '%s\t' "$valueFor_V"
					printf '%s\t' "$valueFor_L"
					printf '%s\n' "$valueFor_i"
				fi

				valueFor_P=''
				valueFor_V=''
				valueFor_L=''
				valueFor_D=''
				valueFor_p=''
				valueFor_i=''
			;;

			*)
				:
			;;

		esac
	done <"$alpine_linux_temporaryFolderPath"/APKINDEX >"$alpine_linux_temporaryFolderPath"/APKINDEX.packages.raw

	exec 3<&-
	exec 4<&-
	exec 5<&-

	exec 6<&-
	exec 7<&-
	exec 8<&-
	exec 9<&-

	local fileNamePart
	for fileNamePart in 'packages' 'provides-so' 'provides-pc' 'provides-binary' 'provides-command' 'provides-virtual-package' 'depends-so' 'depends-pc' 'depends-binary' 'depends-conflicts-package-or-virtual-package' 'depends-package-or-virtual-package'
	do
		sort -k1,2 -t "$(printf '\t')" -h "$alpine_linux_temporaryFolderPath"/APKINDEX.${fileNamePart}.raw >"$alpine_linux_indexFolderPath"/${fileNamePart}.tsv
	done

	set +f
		rm -rf "$alpine_linux_temporaryFolderPath"/APKINDEX.*.raw "$alpine_linux_temporaryFolderPath"/valueFor_*
	set -f
}

depends awk rm
alpine_linux_x_findApkPackage()
{
	local packagesToDownloadFilePath="$1"
	local package="$2"

	printf '%s\n' "$package"

	local dependsOnPackagesFilePath="$alpine_linux_temporaryFolderPath"/"$package".depends-on-packages

	if [ ! -f "$dependsOnPackagesFilePath" ]; then
		
		_alpine_linux_x_findApkPackage_awkDependency()
		{
			dependencyKind="$1"

			resultsFilePath="$alpine_linux_temporaryFolderPath"/"$dependencyKind".dependency
			local awkProgram='BEGIN {FS="\t"}; $1=="'"${package}"'" {print $2}'
			awk "$awkProgram" "$alpine_linux_indexFolderPath"/depends-"$dependencyKind".tsv >"$resultsFilePath"
		}

		_alpine_linux_x_findApkPackage_awkProvides()
		{
			local dependsOn
			while IFS='' read -r dependsOn
			do
				local awkProgram='BEGIN {FS="\t"}; $1=="'"${dependsOn}"'" {print $2}'
				awk "$awkProgram" "$alpine_linux_indexFolderPath"/provides-"$dependencyKind".tsv
			done <"$resultsFilePath"
			rm "$resultsFilePath"
		}

		{
			local dependencyKind
			local resultsFilePath

			# Find the binaries depended on.
			_alpine_linux_x_findApkPackage_awkDependency binary
			_alpine_linux_x_findApkPackage_awkProvides

			# Find the PCs depended on.
			_alpine_linux_x_findApkPackage_awkDependency pc
			_alpine_linux_x_findApkPackage_awkProvides

			# Find the SOs depended on.
			_alpine_linux_x_findApkPackage_awkDependency so
			_alpine_linux_x_findApkPackage_awkProvides

			# TODO: BUG: Package conflicts are not supported.

			# Find the packages depended on.
			_alpine_linux_x_findApkPackage_awkDependency package-or-virtual-package
			local packageDependedOn
			local packageDependedOnWasVirtualPackage
			while IFS='' read -r packageDependedOn
			do
				local awkProgram='BEGIN {FS="\t"}; $1=="'""${packageDependedOn}'" {print $2}'
				packageDependedOnWasVirtualPackage="$(awk "$awkProgram" "$alpine_linux_indexFolderPath"/provides-virtual-package.tsv)"
				if [ -n "$packageDependedOnWasVirtualPackage" ]; then
					printf '%s\n' "$packageDependedOnWasVirtualPackage"
				else
					printf '%s\n' "$packageDependedOn"
				fi
			done <"$resultsFilePath"
			rm "$resultsFilePath"

		} >"$dependsOnPackagesFilePath"
	fi

	while IFS='' read -r packageDependedOn
	do
		alpine_linux_x_findApkPackage "$packagesToDownloadFilePath" "$packageDependedOn"
	done <"$dependsOnPackagesFilePath"
}

depends awk rm
alpine_linux_x_findApkPackages()
{
	local packagesToDownloadFilePath="$alpine_linux_temporaryFolderPath"/packages-to-download

	# Ensure top-level packages are in installation order.
	local topLevelPackagesReversedFilePath="$alpine_linux_temporaryFolderPath"/alpine-linux.packages.reversed
	environment_tac "$alpine_linux_packagesFilePath" >"$topLevelPackagesReversedFilePath"

	{
		local package
		while IFS='' read -r package
		do
			alpine_linux_x_findApkPackage "$packagesToDownloadFilePath" "$package" 
		done <"$topLevelPackagesReversedFilePath"
	} >"$packagesToDownloadFilePath"
	set +f
		rm -rf "$alpine_linux_temporaryFolderPath"/*.depends-on-packages
	set -f
	rm "$topLevelPackagesReversedFilePath"

	# Ensure packages are in installation order.
	environment_tac "$packagesToDownloadFilePath" >"$packagesToDownloadFilePath".reversed
	rm "$packagesToDownloadFilePath"

	# Eliminate duplicate packages.
	awk '!already_seen_lines[$0]++' "$packagesToDownloadFilePath".reversed >"$packagesToDownloadFilePath"-and-in-installation-order

	# Add versioning information
	local package
	while IFS= read -r package
	do
		local awkProgram='BEGIN {FS="\t"; OFS="\t"}; $1=="'"${package}"'" {print $1,$2}'
		awk "$awkProgram" "$alpine_linux_indexFolderPath"/packages.tsv
	done <"$packagesToDownloadFilePath"-and-in-installation-order >"$alpine_linux_packagesFolderPath"/packages-to-install-and-in-installation-order
	rm "$packagesToDownloadFilePath"-and-in-installation-order 
}

alpine_linux_x_downloadApkPackage()
{
	local repositoryVariant="$1"
	local apkName="$2"
	local apkVersion="$3"

	local apkFileName="${apkName}-${apkVersion}.apk"

	local repositoryMirror
	alpine_linux_repositoryMirror "$repositoryVariant"

	environment_download "$alpine_linux_packagesFolderPath" "${repositoryMirror}/${alpine_linux_architecture}/${apkFileName}"
}

depends tar
depends_binary /bin/sh
alpine_linux_x_extractApk()
{
	local apkName="$1"
	local apkVersion="$2"

	local apkFileName="${apkName}-${apkVersion}.apk"

	tar -x -f "$alpine_linux_packagesFolderPath"/"$apkFileName" -C "$alpine_linux_extractFolderPath" 2>/dev/null
}

depends cp
alpine_linux_x_downloadMirror()
{
	if alpine_linux_cachedVersion "$alpine_linux_mirrorFolderPath"; then
		return 0
	fi

	alpine_linux_x_downloadNetboot
	alpine_linux_x_downloadApkIndex 'main'

	cp "$alpine_linux_versionFilePath" "$alpine_linux_mirrorVersionFilePath"
}

depends cp
alpine_linux_x_indexApks()
{
	if alpine_linux_cachedVersion "$alpine_linux_indexFolderPath"; then
		return 0
	fi

	alpine_linux_x_extractApkIndex

	alpine_linux_x_convertApkIndex

	cp "$alpine_linux_versionFilePath" "$alpine_linux_indexVersionFilePath"
}

depends cp
alpine_linux_x_downloadApkPackages()
{
	if alpine_linux_cachedVersion "$alpine_linux_packagesFolderPath"; then
		return 0
	fi

	alpine_linux_x_findApkPackages

	local package
	local version
	local tab='	'
	while IFS="$tab" read -r package version
	do
		alpine_linux_x_downloadApkPackage 'main' "$package" "$version"
	done <"$alpine_linux_packagesFolderPath"/packages-to-install-and-in-installation-order

	cp "$alpine_linux_versionFilePath" "$alpine_linux_packagesVersionFilePath"
	cp "$alpine_linux_packagesFilePath" "$alpine_linux_packagesPackagesFilePath"
}

depends rm mkdir ln chmod cp
alpine_linux_x_extractApks()
{
	if alpine_linux_cachedPackages "$alpine_linux_extractFolderPath"; then
		return 0
	fi

	local package
	local version
	local tab='	'
	while IFS="$tab" read -r package version
	do
		alpine_linux_x_extractApk "$package" "$version"
	done <"$alpine_linux_packagesFolderPath"/packages-to-install-and-in-installation-order

	# Clean up
	rm "$alpine_linux_extractFolderPath"/.dummy
	rm "$alpine_linux_extractFolderPath"/.PKGINFO
	set +f
		rm "$alpine_linux_extractFolderPath"/.SIGN.*
		rm -rf "$alpine_linux_extractFolderPath"/.post-* "$alpine_linux_extractFolderPath"/.trigger
	set -f

	# Assumes busybox-static is one of the packages.
	local binary
	local folder
	local tab='	'
	while IFS="$tab" read -r binary folder
	do

		local symlinkSource
		case "$folder" in

			/bin|/sbin)
				symlinkSource=../bin/busybox.static
			;;

			/usr/bin|/usr/sbin)
				symlinkSource=../../bin/busybox.static
			;;
			
			*)
				fail "Unknown folder '${folder}' for binary '$binary'"
			;;

		esac
		if [ ! -d "${alpine_linux_extractFolderPath}${folder}" ]; then
			mkdir -m 0700 -p "${alpine_linux_extractFolderPath}${folder}"
		fi
		ln -s "$symlinkSource" "${alpine_linux_extractFolderPath}${folder}/${binary}"

	done <"$alpine_linux_busyboxStaticBinariesFilePath"

	# Adjust permissions.
	chmod -R g-rwx,o-rwx -- "$alpine_linux_extractFolderPath"

	cp "$alpine_linux_versionFilePath" "$alpine_linux_extractVersionFilePath"
	cp "$alpine_linux_packagesFilePath" "$alpine_linux_extractPackagesFilePath"
	cp "$alpine_linux_busyboxStaticBinariesFilePath" "$alpine_linux_extractBusyboxStaticBinariesFilePath"
}

depends rm cp
alpine_linux_x_main()
{
	cd "$(_program_path_find)" 1>/dev/null 2>/dev/null

	. "$(pwd)"/alpine-linux.functions.sh

	local environment_parseCommandLineArguments_message="${program_name}:  Downloads and caches an Alpine Linux kernel, initramfs and packages for a basic known build environment.

Usage: ${program_name} -h | --help
Usage: ${program_name} [-c|--configuration /path/to/configuration/folder] [-o|--output /path/to/output/folder]

If the configuration folder path is not provided, it defaults to program_location/configuration.

If the output folder path is not provided, it defaults to program_location/output. The output folder path is created as necessary.
"
	_additionalArgumentsCallback()
	{
		environment_parseCommandLineArguments_errorHelp "Unexpected argument '$key'"
	}
	_positionalArgumentsCallback()
	{
		if [ $# -gt 0 ]; then
			environment_parseCommandLineArguments_errorHelp "Positional arguments are not supported"
		fi
	}
	local alpine_linux_positionalArgumentsStartAt
	local alpine_linux_configurationFolderPath
	local alpine_linux_outputFolderPath
	alpine_linux_parseCommandLineArguments _additionalArgumentsCallback _positionalArgumentsCallback "$@"
	
	alpine_linux_validateCommandLineArguments

	local alpine_linux_temporaryFolderPath
	local alpine_linux_versionFilePath
	local alpine_linux_packagesFilePath
	local alpine_linux_busyboxStaticBinariesFilePath
	local alpine_linux_mirrorFolderPath
	local alpine_linux_mirrorVersionFilePath
	local alpine_linux_indexFolderPath
	local alpine_linux_indexVersionFilePath
	local alpine_linux_packagesFolderPath
	local alpine_linux_packagesVersionFilePath
	local alpine_linux_extractFolderPath
	local alpine_linux_extractVersionFilePath
	local alpine_linux_extractPackagesFilePath
	local alpine_linux_extractBusyboxStaticBinariesFilePath
	local alpine_linux_majorVersion
	local alpine_linux_minorVersion
	local alpine_linux_revisionVersion
	local alpine_linux_apkToolsVersion
	local alpine_linux_versionMirror
	local alpine_linux_releasesMirror
	local alpine_linux_architecture
	alpine_linux_setEnvironmentVariables

	alpine_linux_x_prepare

	local netbootFolderName
	alpine_linux_netbootFolderName

	alpine_linux_x_downloadMirror

	alpine_linux_x_indexApks

	alpine_linux_x_downloadApkPackages

	alpine_linux_x_extractApks

	rm -rf "$alpine_linux_temporaryFolderPath"
}

alpine_linux_x_main "$@"
